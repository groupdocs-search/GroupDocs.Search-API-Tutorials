---
date: '2026-01-11'
description: Узнайте, как создать пользовательский поисковый индекс с помощью GroupDocs.Search
  для Java, настроив обычные и комбинированные символы для продвинутого OCR и поиска
  по изображениям.
keywords:
- GroupDocs.Search Java
- Java OCR character recognition
- search library Java
title: Создание пользовательского поискового индекса с распознаванием символов – GroupDocs.Search
  Java
type: docs
url: /ru/java/ocr-image-search/groupdocs-search-java-character-recognition/
weight: 1
---

# Создание пользовательского поискового индекса с распознаванием символов с помощью GroupDocs.Search для Java

В современных приложениях, работающих с большим количеством документов, **создание пользовательского поискового индекса**, который понимает нюансы вашего текста — такие как дефисы, подчёркивания или специфические для языка символы — является необходимым для быстрого и точного поиска. В этом руководстве мы покажем, как настроить распознавание символов в **GroupDocs.Search для Java**, охватывая как обычные символы (буквы, цифры, подчёркивания), так и комбинированные символы (например, дефисы). По завершении вы сможете адаптировать индекс под точные требования вашего OCR‑или поиска по изображениям.

## Быстрые ответы
- **Что означает «создание пользовательского поискового индекса»?** Это настройка индекса так, чтобы определённые символы рассматривались как буквы или комбинированные символы, а не игнорировались.  
- **Какая библиотека используется?** GroupDocs.Search для Java (v25.4 на момент написания).  
- **Нужна ли лицензия?** Бесплатная пробная версия подходит для разработки; платная лицензия требуется для продакшн‑использования.  
- **Можно ли индексировать и PDF, и изображения?** Да — GroupDocs.Search поддерживает OCR для изображений и PDF при правильной конфигурации.  
- **Обязательно ли использовать Maven?** Maven — рекомендованный способ управления зависимостями, но можно также использовать Gradle или подключать JAR‑файлы вручную.

## Что такое пользовательский поисковый индекс?
Пользовательский поисковый индекс позволяет задать, как поисковый движок интерпретирует символы. По умолчанию многие символы игнорируются, что может приводить к пропуску совпадений, например, номеров дел (`ABC-123`) или фрагментов кода (`my_variable`). Настройка словаря алфавита даёт полный контроль над тем, какие символы считаются поисковым текстом.

## Почему нужно настраивать обычные и комбинированные символы?
- **Обычные символы** (буквы, цифры, подчёркивания) рассматриваются как отдельные токены, улучшая точный поиск.  
- **Комбинированные символы** (дефисы, слеши) соединяют слова; их настройка предотвращает нежелательное разбиение токенов, что критично для юридических ссылок, артикулов продукции или индексации исходного кода.

## Предварительные требования
- **JDK 8** или более новая версия.  
- **Maven** для управления зависимостями.  
- Доступ к библиотеке **GroupDocs.Search для Java** (скачивается через Maven или с официального сайта).  

### Необходимые библиотеки и зависимости
Добавьте репозиторий и зависимости в ваш `pom.xml` (как показано ниже). XML‑блок должен оставаться без изменений.

```xml
<repositories>
   <repository>
      <id>repository.groupdocs.com</id>
      <name>GroupDocs Repository</name>
      <url>https://releases.groupdocs.com/search/java/</url>
   </repository>
</repositories>

<dependencies>
   <dependency>
      <groupId>com.groupdocs</groupId>
      <artifactId>groupdocs-search</artifactId>
      <version>25.4</version>
   </dependency>
</dependencies>
```

Вы также можете загрузить последние JAR‑файлы по ссылке [GroupDocs.Search for Java releases](https://releases.groupdocs.com/search/java/).

### Приобретение лицензии
- **Free Trial** — идеален для ранних экспериментов.  
- **Temporary License** — полезна для длительных циклов разработки.  
- **Production License** — требуется для коммерческого развертывания.  

Получить лицензию можно на официальном портале: [GroupDocs](https://purchase.groupdocs.com/temporary-license/).

### Базовая инициализация
Ниже приведён минимальный код для создания пустого индекса. Оставьте его без изменений; позже мы будем его расширять.

```java
import com.groupdocs.search.*;

public class GroupDocsSearchSetup {
    public static void main(String[] args) {
        String indexFolder = "YOUR_OUTPUT_DIRECTORY";
        String documentFolder = "YOUR_DOCUMENT_DIRECTORY";

        Index index = new Index(indexFolder);
        
        System.out.println("GroupDocs.Search setup completed!");
    }
}
```

## Настройка GroupDocs.Search для Java

### Установка через Maven
Конфигурация Maven из раздела *Предварительные требования* — всё, что нужно. После добавления выполните `mvn clean install` для загрузки бинарных файлов.

### Требования к окружению
- Убедитесь, что **папка индекса** и **папка документов** существуют на диске.  
- Используйте абсолютные пути или настройте IDE для корректного разрешения относительных путей.  

## Руководство по реализации

Ниже рассмотрены две отдельные функции: **обычные символы** и **комбинированные символы**. Каждая функция следует одинаковому шаблону — задаём пути, создаём индекс, настраиваем словарь символов и, наконец, индексируем документы.

### Функция 1 — Обычные символы

#### Обзор
Обычные символы рассматриваются как независимые токены. Это удобно, когда нужно, чтобы цифры, буквы и подчёркивания искались точно в том виде, в каком они записаны.

#### Пошаговая реализация

**1️⃣ Задание путей**  
Определите, где будет храниться индекс и где находятся исходные документы.

```java
String indexFolder = "YOUR_OUTPUT_DIRECTORY/AdvancedUsage/Indexing/CharacterTypes/RegularCharacters";
String documentFolder = "YOUR_DOCUMENT_DIRECTORY";
```

**2️⃣ Создание и настройка индекса**  
Создайте объект индекса и очистите любую предустановленную конфигурацию алфавита.

```java
Index index = new Index(indexFolder);
index.getDictionaries().getAlphabet().clear();
```

**3️⃣ Определение обычных символов**  
Сформируйте массив символов, включающий цифры, латинские буквы и подчёркивание.

```java
StringBuilder sb = new StringBuilder();
for (char i = 0x0030; i <= 0x0039; i++) { // Digits
    sb.append(i);
}
for (char i = 0x0041; i <= 0x005A; i++) { // Latin capital letters
    sb.append(i);
}
sb.append(0x005F); // Underscore
for (char i = 0x0061; i <= 0x007A; i++) { // Latin small letters
    sb.append(i);
}

// Convert to character array and set as alphabet range
char[] characters = new char[sb.length()];
sb.getChars(0, sb.length(), characters, 0);
index.getDictionaries().getAlphabet().setRange(characters, CharacterType.Letter);
```

**4️⃣ Индексация документов**  
Добавьте все файлы из исходной папки в только что настроенный индекс.

```java
index.add(documentFolder);
```

### Функция 2 — Комбинированные символы

#### Обзор
Комбинированные символы (например, дефис) часто соединяют два слова. Пометка их как *комбинированных* заставляет движок сохранять окружающие токены вместе при индексации.

#### Пошаговая реализация

**1️⃣ Задание путей**  

```java
String indexFolder = "YOUR_OUTPUT_DIRECTORY/AdvancedUsage/Indexing/CharacterTypes/BlendedCharacters";
String documentFolder = "YOUR_DOCUMENT_DIRECTORY";
```

**2️⃣ Создание и настройка индекса**  

```java
Index index = new Index(indexFolder);
```

**3️⃣ Определение комбинированных символов**  
Здесь мы указываем словарю, что дефис следует рассматривать как комбинированный символ.

```java
index.getDictionaries().getAlphabet().setRange(new char[] { '-' }, CharacterType.Blended);
```

**4️⃣ Индексация документов**  

```java
index.add(documentFolder);
```

## Практические применения

### Сценарий 1 — Управление юридическими документами
Юридические файлы часто содержат номера дел, например `2023-AB-456`. Настроив подчёркивания и дефисы, поиск будет возвращать точные совпадения без разбиения идентификатора.

### Сценарий 2 — Репозитории исходного кода
Разработчикам необходимо искать фрагменты кода, где подчёркивания (`my_variable`) и дефисы (`my-function`) имеют смысл. Пользовательское распознавание символов гарантирует, что поисковый движок учитывает эти знаки.

### Сценарий 3 — Многоязычные наборы данных
Работая с языками, использующими дополнительные алфавиты, можно расширить набор обычных символов, включив соответствующие диапазоны Unicode, обеспечивая точный кросс‑языковой поиск.

## Соображения по производительности

- **Управление ресурсами** — следите за использованием heap; большие индексы выигрывают от инкрементных коммитов.  
- **Сборка мусора** — освобождайте объекты `Index`, когда они больше не нужны, чтобы JVM могла вернуть память.  
- **Оптимизация индекса** — периодически вызывайте `index.optimize()` (если доступно) для уплотнения индекса и ускорения запросов.  

## Заключение

Теперь вы знаете, как **создать пользовательский поисковый индекс**, различающий обычные и комбинированные символы с помощью GroupDocs.Search для Java. Такой тонко настроенный контроль позволяет строить OCR‑ориентированные, высокопроизводительные поисковые решения для юридических, разработческих или многоязычных окружений.

**Следующие шаги**  
- Поэкспериментировать с дополнительными диапазонами Unicode для нелатинских алфавитов.  
- Скомбинировать настройку символов с другими возможностями GroupDocs.Search, такими как стемминг или синонимы.  
- Интегрировать индекс в REST‑API для предоставления поисковых возможностей фронтенд‑приложениям.

## Часто задаваемые вопросы

**В:** *Какова цель `CharacterType.Letter`?*  
**О:** Он указывает индексу рассматривать переданные символы как обычные буквы, поэтому они токенизируются отдельно при индексации.

**В:** *Можно ли смешивать обычные и комбинированные символы в одном индексе?*  
**О:** Да — достаточно вызвать `setRange` для каждого типа; словарь одновременно обработает обе конфигурации.

**В:** *Нужно ли перестраивать индекс после изменения алфавита?*  
**О:** Обязательно. Изменения в словаре символов влияют на токенизацию, поэтому необходимо переиндексировать документы, чтобы новые правила вступили в силу.

**В:** *Есть ли ограничение на количество пользовательских символов?*  
**О:** Библиотека поддерживает полный диапазон Unicode; производительность может ухудшиться при добавлении чрезвычайно большого набора, поэтому ограничьте его только необходимыми символами.

**В:** *Как это влияет на точность OCR?*  
**О:** Согласование набора символов индекса с выводом OCR‑движка уменьшает количество ложных отрицаний и повышает общую релевантность поиска.

---

**Последнее обновление:** 2026-01-11  
**Тестировано с:** GroupDocs.Search 25.4 для Java  
**Автор:** GroupDocs  

---